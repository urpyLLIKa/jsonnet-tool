# Jsonnet Tool

`jsonnet-tool` is a simple binary, primarily used to build YAML configuration files from Jsonnet source configurations.

## Commands

### `jsonnet-tool yaml`

```console
$ cat file.jsonnet
{
  'file.yaml': std.manifestYamlDoc({
    hello: true,
    there: 1,
    moo: {
      there: 1,
      hello: true,
    },
  }),
}
$ jsonnet-tool yaml \
    --multi "./output" \ #       - Directory to emit the YAML file to
    --header "# DO NOT EDIT" \ # - Header to prefix to output YAML
    -J "./libsonnet/" \ #        - Jsonnet Import Search Path
    -J "./vendor/" \ #           - .. supports multiple
    -P name \ #                  - Keys to appear at the top of YAML
    -P alert \ #                 - .. supports multiple
    --prefix "autogenerated-" \  - Prefix added to file names
    file.jsonnet
```

### `jsonnet-tool render`

Render is a generic rendering utility for jsonnet. In the case of JSON and YAML, the output does not need to be manifested, the tool will use
the extension of the file to appropriately manifest the output.

```console
$ cat file.jsonnet
{
  // File will contain YAML output
  'file.yaml': {
    hello: true,
    there: 1,
    moo: {
      there: 1,
      hello: true,
    },
  },

  // Subdirectories are automatically created
  'x/y/z/file.json': {
    hello: 1,
    x: [1, 2, 3],
  },
}
$ jsonnet-tool render \
    --multi "./output" \ #       - Directory to emit the YAML file to
    -J "./libsonnet/" \ #        - Jsonnet Import Search Path
    -J "./vendor/" \ #           - .. supports multiple
    --prefix "autogenerated-" \  - Prefix added to file names
    file.jsonnet
```

### `jsonnet-tool checksum`

Checksum will recursively parse imports in a jsonnet file and generate a full import tree, then output sha256 hashes for the entire tree
in a format that can be consumed by the sha256sum utility.

This is useful for caching jsonnet files.

```console
$ cat file.jsonnet
local stageGroupMapping = (import 'gitlab-metrics-config.libsonnet').stageGroupMapping;
local serviceCatalog = import 'service-catalog/service-catalog.libsonnet';
{}

$ jsonnet-tool checksum \
    -J . -J ../libsonnet -J ../metrics-catalog/ -J ../vendor -J ../services \
    file.jsonnet >file.jsonnet.sha256sum

$ cat file.jsonnet.sha256sum
0007482aebcdf09ed0798a499118f31d40ca244c71bd89a9ff9c947e26ed71a0  ../libsonnet/saturation-monitoring/shard_cpu.libsonnet
047b0b518845b0c38f6775a4e3040c08c3ce2bbfcdb870d9f30e3b190d1917e5  ../libsonnet/elasticlinkbuilder/index_catalog.libsonnet
0599206409b75d4bd1c896ee2b865166eb516ab23bcf45d0fa60a398690b0692  ../metrics-catalog/services/woodhouse.jsonnet
...

$ sha256sum --check --status <file.jsonnet.sha256sum
```

## `jsonnet-tool test`

This tool allows for Jsonnet manifested output to be tested against fixture files.

The term "manitest" is a portmanteau of "manifest" and "test".

Each test case is kept in a file with the `.manitest.jsonnet` suffix.

```jsonnet
{
  // Each test case has an arbitrary name
  testcase1: {
    actual: a_function_being_tested(),
    expectJSON: './fixtures/test1.testcase1.json',
  },
  // Each test case has an arbitrary name
  testcase2: {
    actual: std.manifestYamlDoc({ hello: 'world' }),
    expectYAML: './fixtures/test1.testcase2.yaml',
  },
}
```

### Expectation Matchers

At present, two types of expectation matchers are available:

1. `expectJSON` will match the actual value against a JSON fixture file.
1. `expectYAML` will match the actual value against a YAML fixture file.
1. Additional expectation matchers will be added an necessary.

```console
$ cat examples/tests/test1.manitest.jsonnet
{ ... }
$ jsonnet-tool test examples/tests/test1.manitest.jsonnet
▶️  Executing manitest examples/tests/test1.manitest.jsonnet
  ✔️  testcase1
  ✔️  testcase2
  Completed examples/tests/test1.manitest.jsonnet
```

### Caching

Jsonnet test performance can be greatly improved by caching results. The `jsonnet-tool test` harness will analyze which files and fixtures,
including all dependencies imported via `import`, `importstr`, `importbin` etc and, if the none of the files have changes, skip them from
the test run.

Since `jsonnet` is hermitic, meaning that the output is always the same if the input and files are the same, this is a safe operation.

Caching can be enabled with the `--cache` flag.

```
$ time jsonnet-tool test --cache examples/tests/test1.manitest.jsonnet
▶️  Executing manitest examples/tests/test1.manitest.jsonnet
  ✔️  examples/tests/test1.manitest.jsonnet (all tests) (cached)
  Completed examples/tests/test1.manitest.jsonnet
./jsonnet-tool test examples/tests/test1.manitest.jsonnet --cache  0.00s user 0.01s system 2% cpu 0.593 total
```

### Diffing

`jsonnet-tool test` will include color-coded diff comparing the actual and expected values.

```
$ jsonnet-tool test  examples/tests/test1.manitest.jsonnet
▶️  Executing manitest examples/tests/test2.manitest.jsonnet
  ❌  testcase1 failed      examples/tests/fixtures/test1.testcase1.json
    {
      "bad": "field",
      "hello": "world"
    }

  ✔️  testcase2
  Failed examples/tests/test2.manitest.jsonnet 2 test(s) completed with 1 failure(s)
```

### Rewriting Fixtures

When performing large refactors, it can sometimes be preferable to simply rewrite all fixtures and carefully review the changes
instead of manually updating each fixture.

`jsonnet-tool test` can perform this, using the `--write-fixtures` option.

```
$ jsonnet-tool test  examples/tests/test1.manitest.jsonnet --write-fixtures
▶️  Executing manitest examples/tests/test1.manitest.jsonnet
  ✔️  testcase1
  ✔️  testcase2
  Completed examples/tests/test1.manitest.jsonnet
$ git diff
# compare output and, if correct, commit the change
```

## Examples

Check the [`examples/`](examples/) directory for examples of files suitable for `jsonnet-tool`.

## Issue creation

Please create new issues in the [public infrastructure project](https://gitlab.com/gitlab-com/gl-infra/infrastructure/-/issues/) and not in this private issue tracker.

## Project Workflow

**[CONTRIBUTING.md](CONTRIBUTING.md) is important, do not skip reading this.**
